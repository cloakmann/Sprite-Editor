<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

display = instance_create(x + 20, y + 10 + 20, objMenuDemoDisplay);
display.parent = id;


save = instance_create(x + objGenBlockMenu.menuWidth - 50 - 32, y + 10 + 16 + 20, objMenuSaveButton);
save.parent = display.id;

surf = surface_create(32,32);
surf2 = surface_create(32,32);

//this surf is for template drawing shiny effect
surf3 = surface_create(32,32);

//surfSpike - surfCrop = spike + effect

//the long sprite with (common spike + effect_rect)
surfSpike = surface_create(32,32)

//the long sprite with spike template for later cropping
surfCrop = surface_create(32,32)

scrCheckSingleton();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(surf))surface_free(surf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
while(sprite_exists(objDisplay.sprite_index)){
    
    //when objSetSpikeEffect changes style
    //recreate this surface
    var tempWidth;
    if (objSetSpikeEffect.currentStyle){
        tempWidth = 32*objSetSpikeEffect.numOfFrames.value * 32;
    }
    else {
        tempWidth = 32;
    }
    if(tempWidth != surface_get_width(surf)){
        //if (surface_exists(surf))surface_free(surf)
        if (surface_exists(surf))surface_resize(surf,tempWidth,32);
        if (surface_exists(surfSpike))surface_resize(surfSpike,tempWidth,32);
        if (surface_exists(surfCrop))surface_resize(surfCrop,tempWidth,32);
    }
    
    
    //if surf does not exist create new one
    if (!surface_exists(surf)){
        if(objSetSpikeEffect.currentStyle == 0)surf = surface_create(32,32);
        else {
            //recreate a new surf according to numOfFrames
            var tempWidth = 32*objSetSpikeEffect.numOfFrames.value;
            var tempHeight = 32;
            surf = surface_create(tempWidth,tempHeight);
            //show_message("recreated width: " + string(tempWidth) + " height: " + string(tempHeight))
        }
    }
    if (!surface_exists(surf2))surf2 = surface_create(32,32);
    if (surface_exists(surfSpike))surface_resize(surfSpike,tempWidth,32);
    if (surface_exists(surfCrop))surface_resize(surfCrop,tempWidth,32);

    
    //draw the surface
    if(objSetSpikeEffect.currentStyle == 0){
        surface_set_target(surf);
        draw_clear_alpha(c_black,0);
        shader_set(shadCustomSV);
        shader_set_uniform_f(global.uni_saturation,global.saturation);
        shader_set_uniform_f(global.uni_value,global.value);
        /*
        with(objDisplay){        
            draw_sprite_ext(sprite_index,image_index,0,0,32/sprite_width,32/sprite_height,image_angle,image_blend,image_alpha);   
        }
        */
        draw_surface(global.displaySurf,0,0);
        
        draw_set_blend_mode_ext(bm_zero,bm_src_alpha);
        draw_sprite(sprSpikeTemplate,0,0,0);
        scrResetFormat();
        
        //scrDrawSpikeBorder();
        
        var color1 = objSetSpriteBorder.color1.color;
        var color2 = objSetSpriteBorder.color2.color;
        var width = objSetSpriteBorder.currentWidth;
        var trans = objSetSpriteBorder.currentTransparency;
        scrDrawSpikeBorder2(0,0,color1,color2,width,trans);
        surface_reset_target();
        //shader_reset();
    }
    else{
        //clear the two surfaces first
        if(surface_exists(surfSpike)){
            surface_set_target(surfSpike);
            draw_clear_alpha(c_black,0);
            surface_reset_target();
        }
        if(surface_exists(surfCrop)){
            surface_set_target(surfCrop);
            draw_clear_alpha(c_black,0);
            surface_reset_target();
        }
        
        var tempFrameNum = objSetSpikeEffect.numOfFrames.value;
        var tempRange = 32 + objSetSpikeEffect.setWidth.value;
        var color = objSetSpikeEffect.color.color;
        var width = objSetSpikeEffect.setWidth.value;
        var alpha = objSetSpikeEffect.setTrans.value;
        
        
        for(i = 0; i &lt; tempFrameNum; i++){
            //draw 32 * 32 * tempFrameNum displaySurf
            surface_set_target(surfSpike);
            draw_surface(global.displaySurf,32 * i, 0);
            //draw the effect
            scrDrawShinyRect2(tempRange,tempFrameNum,color,alpha,width);
            scrResetFormat();
            surface_reset_target();
            
            //draw32 * 32 * 5 sprSpikeTemplate
            surface_set_target(surfCrop);
            draw_sprite(sprSpikeTemplate,0,32 * i,0);
            scrResetFormat();
            surface_reset_target();
        }
        
        //crop surfSpike
        surface_set_target(surfSpike);
        draw_set_blend_mode_ext(bm_zero,bm_src_alpha);
        draw_surface(surfCrop,0, 0);
        scrResetFormat();
        surface_reset_target();
    
        shader_set(shadCustomSV);
        shader_set_uniform_f(global.uni_saturation,global.saturation);
        shader_set_uniform_f(global.uni_value,global.value);
        
        
        //draw the borders
        var color1 = objSetSpriteBorder.color1.color;
        var color2 = objSetSpriteBorder.color2.color;
        tempWidth = objSetSpriteBorder.currentWidth;
        tempTrans = objSetSpriteBorder.currentTransparency;
        
        surface_set_target(surf);
        draw_surface(surfSpike,0,0);
        for(i = 0; i &lt; tempFrameNum; i++){
            scrDrawSpikeBorder2(i * 32, 0,color1,color2,tempWidth,tempTrans);
        }
        scrResetFormat();
        surface_reset_target();
        shader_reset()
    }
    
    //assign the sprite_index to display object
    with(display){
        
        var tempSpriteDest = -1;
        var tempSpriteSrc = -1;
        var tempOutputSprite = -1;
        if(objSetSpikeEffect.currentStyle != 0){
            
            //need multi subimage
            var tempWidth = surface_get_width(other.surf);
            var tempHeight = surface_get_height(other.surf);
            
            //window_set_caption("multi" + " w: " + string(tempWidth) + " h: " + string(tempHeight))
            tempOutputSprite = sprite_create_from_surface(other.surf,0,0,tempWidth,tempHeight,0,1,0,0);

        }
        else {
            //no need for multi subimage
            tempOutputSprite = sprite_create_from_surface(other.surf,0,0,32,32,0,1,0,0);
        }
        
        multiImage = (objSetSpikeEffect.currentStyle != 0);
        
        if !sprite_exists(sprite_index) {
            //assign new sprite
            sprite_index = tempOutputSprite;
        }
        else {
            //replace new sprite
            sprite_delete(sprite_index);
            sprite_index = tempOutputSprite;
        }
        
    }
    
    exit;
}

exit;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_text(x + 20, y, "normal spike");
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
