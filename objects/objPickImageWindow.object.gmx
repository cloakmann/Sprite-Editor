<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-50000</depth>
  <persistent>-1</persistent>
  <parentName>objWindow</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>x = 0;
y = 0;

//xy for original sprite display
displayX = 50;
displayY = 50;

//controls the angle for capturing the surface( 90 degrees' multiples!)
angle = 0;

close = instance_create(room_width - 40, y + 8, objCloseWindow);
close.parent = id;




for (i = 0; i &lt; 10; i += 1){
    //image_scale for picked up surface = (i + 1) / 2
    pickChoice[i] = 8 * (i + 1);
}

for (i = 0; i &lt; 10; i += 1){
    //image_scale for picked up surface = (i + 1) / 2
    pickDiv[i] = 8 * (i + 1);
}

pickSize = pickChoice[1];
pickGap = pickDiv[1];

rawImage = surface_create(320,320)
pick = surface_create(pickSize * 2,pickSize * 2)


pickX = displayX + pickSize;
pickY = displayY + pickSize;


//the buttons for pickSize
for (i = 0; i &lt; 10; i += 1){
    pickSizeButtons[i] = instance_create(x,y,objOutlinedButton);
    pickSizeButtons[i].parent = id;
    pickSizeButtons[i].setValue = pickChoice[i];
    pickSizeButtons[i].width = 32;
    pickSizeButtons[i].height = 32;
}

//the buttons for pickGap
for (i = 0; i &lt; 10; i += 1){
    pickGapButtons[i] = instance_create(x,y,objOutlinedButton);
    pickGapButtons[i].parent = id;
    pickGapButtons[i].setValue = pickDiv[i];
    pickGapButtons[i].width = 32;
    pickGapButtons[i].height = 32;
}


//the buttons for rotation

for (i = 0; i &lt; 4; i += 1){
    rotationButtons[i] = instance_create(x,y,objOutlinedButton);
    rotationButtons[i].parent = id;
    rotationButtons[i].setValue = 90 * i;
    rotationButtons[i].width = 60;
    rotationButtons[i].height = 40;
}

//the confirm button
confirmButton = instance_create(x,y,objOutlinedButton);
confirmButton.parent = id;
confirmButton.isTextButton = true;
confirmButton.buttonTitle = "Confirm"
confirmButton.width = 150;
confirmButton.height = 40;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(rawImage))surface_free(rawImage);
if (surface_exists(pick))surface_free(pick);

with objOutlinedButton if (parent == other.id) instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if(scrCursorWithin(50,50,50 + 320,50 + 320)){
    if(mouse_check_button(mb_left)){

        pickX = mouse_x - 50;
        pickY = mouse_y - 50;
        //pickX and pickY should lies in [pickSize, 320 - pickSize] range
        //pickX and pickY should be multiples of pickGap
        pickX = 50 + min(max(pickSize,floor(pickX / pickGap) * pickGap),320 - pickSize)
        pickY = 50 + min(max(pickSize,floor(pickY / pickGap) * pickGap),320 - pickSize)
    }
}


/*
if(scrCursorWithin(displayX,displayY,displayX + 320,displayY + 320)){
    if(mouse_check_button(mb_left)){

        pickX = mouse_x - displayX;
        pickY = mouse_y - displayY;
        //pickX and pickY should lies in [pickSize, 320 - pickSize] range
        //pickX and pickY should be multiples of pickGap
        pickX = displayX + min(max(pickSize,floor(pickX / pickGap) * pickGap),320 - pickSize)
        pickY = displayY + min(max(pickSize,floor(pickY / pickGap) * pickGap),320 - pickSize)
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>displayX = 50;
displayY = 50;


var refresh = false;


if (sprite_exists(sprite_index)){
    //draw the display area
    if(!surface_exists(pick))pick = surface_create(pickSize * 2,pickSize * 2)
    if(!surface_exists(rawImage))rawImage = surface_create(320,320)
    
    //draw the window background
    draw_set_color(c_black);
    draw_rectangle(0,0,room_width,room_height,0);
    scrResetFormat();
    
    //draw the raw image
    
    surface_set_target(rawImage);
    draw_clear_alpha(c_black,0);
    draw_sprite_ext(sprite_index,0,0,0,320/sprite_width,320/sprite_height,0,image_blend,image_alpha);
    surface_reset_target();
    draw_surface(rawImage,displayX,displayY)
    
    //draw the white frame
    scrDrawRectangleWidth(displayX,displayY,displayX + 320, displayY + 320, 2)

    displayY += 320;    
    //draw the set pick area size section
    draw_text(displayX,displayY + 16,"pick size")
    
    for (i = 0; i &lt; 10; i += 1){
        pickSizeButtons[i].x = displayX + 32 * i;
        pickSizeButtons[i].y = displayY + 40;

        if(pickSizeButtons[i].value == pickSizeButtons[i].setValue and pickSizeButtons[i].cursorWithin){
            if(pickChoice[i] &lt; pickSize){
                pickX -= pickSize - pickChoice[i]
                pickY -= pickSize - pickChoice[i]
                pickSize = pickChoice[i];
                if(pickGap &gt;= pickSize){
                    pickGap = pickSize;
                }
            }
            else {
                pickSize = pickChoice[i];
                refresh = true;
            }
            if(surface_exists(pick)){
                surface_free(pick);
                pick = surface_create(2 * pickSize,2 * pickSize)
            }
        }
        
    }
    
    //get the picked surface and draw the 32 * 32 demo for output
    displayY += 40;
    draw_text(displayX,displayY + 32 + 16,"pickup area move range");
    
    //draw the set pick area move gap section
    for (i = 0; i &lt; 10; i += 1){
        pickGapButtons[i].x = displayX + 32 * i;
        pickGapButtons[i].y = displayY + 32 + 16 + 32;

        if(pickGapButtons[i].value == pickGapButtons[i].setValue and pickGapButtons[i].cursorWithin){
            if(pickDiv[i] &lt;= pickSize and pickGapButtons[i].value != pickGap){
                pickGap = pickDiv[i];
                refresh = true;
            }
        }
    }

    //if pickSize or pickGap is changed refresh pickX and pickY
    if(refresh){
        refresh = false;
        var grids = 320 / pickSize;
                
        //pickX and pickY converted to 50 + multiple of pickSize
        var curPickX = floor(pickX - 50)/pickSize;
        var curPickY = floor(pickY - 50)/pickSize;
        
        //curPickX and curPickY should lie in [1, grids - 1]
        var curPosX = min(grids - 1, max(1, curPickX))
        var curPosY = min(grids - 1, max(1, curPickY))
        
        //pickX = 50 + pickSize * current position in grids
        pickX = 50 + pickSize * curPosX;
        pickY = 50 + pickSize * curPosY;
    }
        
    //draw sprPick to indicate the chosen area
    draw_sprite_ext(sprPick,0,pickX,pickY,pickSize / 16, pickSize / 16, 0,c_white,image_alpha);
    //scrResetFormat()
    
    //get the chosen area surface
    displayX += 400;
    displayY = 50;
    
    //draw the rotation buttons first to get the rotation value
    displayY += 300;

    draw_text(displayX, displayY, "rotation angle(anti-clockwise)")
    
    
    displayY += 30;
    var buttonWidth = 65;
    for (var i = 0; i &lt; 4; i ++){
        rotationButtons[i].x = displayX + buttonWidth * i;
        rotationButtons[i].y = displayY;
        if(rotationButtons[i].value == rotationButtons[i].setValue and rotationButtons[i].cursorWithin and mouse_check_button_pressed(mb_left)){
            angle = rotationButtons[i].setValue;
        }
    }
    
    displayY -= 330;
    
    surface_set_target(pick);
    draw_clear_alpha(c_black,0);
    var drawX,drawY;

    //rotate the captured image to the corr. value
    switch(angle){
        case 0:
            drawX = 0;
            drawY = 0;
            break;
        case 90:
            //drawX = pickX - pickSize - 50 + 2 * pickSize;
            drawX = 0;
            drawY = surface_get_height(pick);
            break;
        case 180:
            drawX = surface_get_width(pick);
            drawY = surface_get_height(pick);
            break;
        case 270:
            drawX = surface_get_width(pick);
            drawY = 0;
            break;
        default:
            drawX = 0;
            drawY = 0;
            break;
    }
    
    draw_surface_general(rawImage,pickX - pickSize - 50,pickY - pickSize - 50,2 * pickSize, 2 * pickSize, drawX,drawY,
        1,1,angle,c_white,c_white,c_white,c_white,1)
    surface_reset_target();
    
    //draw the chosen surface title
    draw_text(displayX, displayY, "demo captured picture")
    
    //draw the chosen surface
    draw_surface_ext(pick,displayX,displayY + 24,250/(2 * pickSize),250/(2 * pickSize),0,image_blend,image_alpha)
    scrDrawRectangleWidth(displayX,displayY + 25,displayX + 250, displayY + 25 + 250, 2)
    
    //draw the confirm button
    displayY += 380;
    confirmButton.x = displayX + 50;
    confirmButton.y = displayY + 40;
    if(confirmButton.cursorWithin and confirmButton.value == confirmButton.setValue){
        with (objDisplay){
                sprite_index = sprite_create_from_surface(other.pick,0,0,surface_get_width(other.pick),surface_get_width(other.pick),0,0,0,0);
            }
        with(objCloseWindow)event_user(0)
    }
        
    scrResetFormat()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
